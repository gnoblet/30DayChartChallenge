{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Day 19: Smooth\"\n",
        "format: html\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "This time, I'll plot the World Food Programme Prices data. First, we get data from the '''Global WFP Food Prices'' dataset from the HDX API. and remove the first row which contains tags.\n"
      ],
      "id": "63a6104e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from hdx.utilities.easy_logging import setup_logging\n",
        "from hdx.api.configuration import Configuration\n",
        "from hdx.data.dataset import Dataset\n",
        "import pandas as pd"
      ],
      "id": "8a51bbf4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# setup\n",
        "setup_logging()\n",
        "Configuration.create(\n",
        "  hdx_site = \"prod\",\n",
        "  user_agent=\"@gnoblet_30DayChartChallenge\",\n",
        "  hdx_read_only = True)\n",
        "\n",
        "dataset = Dataset.read_from_hdx(\"global-wfp-food-prices\")\n",
        "url = dataset.get_resource()['url']\n",
        "\n",
        "# get csv from url\n",
        "df = pd.read_csv(url, dtype = str)\n",
        "\n",
        "# remove first row\n",
        "df = df.iloc[1:]"
      ],
      "id": "899b515b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Let's keep only Sub-Saharan countries in the West African region (using XOF, recorded as such in the dataset). Let's also focus on the local prices for rice.\n"
      ],
      "id": "25244e90"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# keep only Sub-Saharan countries curreency being set to XOF\n",
        "df = df[df['currency'] == 'XOF']\n",
        "\n",
        "# keep only local prices for rice\n",
        "df = df[df['commodity_id'] == '71']"
      ],
      "id": "d0fd3c9e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "There is some needed data wrangling now since there are different units, and in particular where the unit is 1KG, only KG is written in column 'unit'."
      ],
      "id": "93aa8b18"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# split at the first space\n",
        "splits = df['unit'].str.split(' ', n = 1, expand=True)\n",
        "\n",
        "# If the first part is not numeric, move it to the second part and set the first to '0'\n",
        "mask_text_only = ~splits[0].str.isnumeric()\n",
        "splits.loc[mask_text_only, 1] = splits.loc[mask_text_only, 0]\n",
        "splits.loc[mask_text_only, 0] = '1'\n",
        "\n",
        "# Fill NaN in the second part with None or ''\n",
        "splits[1] = splits[1].fillna('')\n",
        "\n",
        "# Assign columns\n",
        "df['div'] = splits[0].astype(int)\n",
        "df['unit_only'] = splits[1]\n",
        "\n",
        "# price as double\n",
        "df['price'] = df['price'].astype(float)\n",
        "\n",
        "# case_when\n",
        "# if unit_only is KG, divide price by div\n",
        "# if unit_only is marmite, divide price by 2.5 (FAO: marmite is 2.5kg, seems to be in Haiti only, can be removed eventually since HTI is not XOF)\n",
        "df['price_kg'] = df.apply(lambda x: x['price'] / x['div'] if x['unit_only'] == 'KG' else x['price'] / 2.5, axis=1)"
      ],
      "id": "dd943e6b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now, before I move on to plot, I want to get the median price by country and date, and get neat country names. For this, I need to convert the date column to datetime, summarize and get unique median price by countryiso3 and date, and add country names from a wonderful iso dictionary."
      ],
      "id": "227a6ba5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "df['date'] = pd.to_datetime(df['date'])\n",
        "df = df.sort_values('date')\n",
        "\n",
        "# summarize and get unique median price by countryiso3 and date\n",
        "df = df.groupby(['countryiso3', 'date'])['price_kg'].median().reset_index()"
      ],
      "id": "253d76d7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# add country names from iso dictionary\n",
        "iso = {\n",
        "  'BEN': 'Benin',\n",
        "  'BFA': 'Burkina Faso',\n",
        "  'CIV': 'Ivory Coast',\n",
        "  'GNB': 'Guinea-Bissau',\n",
        "  'MLI': 'Mali',\n",
        "  'NER': 'Niger',\n",
        "  'SEN': 'Senegal'\n",
        "}\n",
        "\n",
        "df['country_name'] = df['countryiso3'].map(iso)"
      ],
      "id": "4d175b93",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "On to the plot! Using `seaborn` now we will plot time series of prices using small multiples by country. Let's load the packages needed and set up the theme.\n"
      ],
      "id": "5b8c9c4c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# load libraries\n",
        "import seaborn as sns\n",
        "import matplotlib.dates as mdates\n",
        "import textwrap\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# set up a theme\n",
        "sns.set_theme(\n",
        "    style = 'whitegrid',\n",
        "    font = 'Carlito',\n",
        "    rc = {\n",
        "        \"grid.linewidth\": 0.3,\n",
        "        'figure.figsize':(9,6)\n",
        "    }\n",
        ")"
      ],
      "id": "eb5d0c7c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "There are only seven countries in this dataset. I add dummy rows to be able to plot empty countries first that will leave space for the plot title on the basis of a 3-column row. There may very well be more elegant solutions but I couldn't find any.\n",
        "\n",
        "The plot follows this structure:\n",
        "- use sns.relplot to plot each year's time series in its own facet;\n",
        "- loop through each facet to add all countries except the dummy ones.\n"
      ],
      "id": "c24091ea"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# add dummy rows to plot emoty countries first\n",
        "dummy_rows = pd.DataFrame({\n",
        "    'date': [df['date'].min(), df['date'].min()],\n",
        "    'price_kg': [None, None],\n",
        "    'country_name': ['cty1', 'cty2']\n",
        "})\n",
        "df2 = pd.concat([dummy_rows, df], ignore_index=True)\n",
        "\n",
        "# plot each year's time series in its own facet\n",
        "g = sns.relplot(\n",
        "    data = df2,\n",
        "    x = \"date\",\n",
        "    y = \"price_kg\",\n",
        "    col = \"country_name\",\n",
        "    hue = \"country_name\",\n",
        "    kind = \"line\",\n",
        "    palette = \"Set2\",\n",
        "    linewidth = 4,\n",
        "    zorder = 5,\n",
        "    col_wrap = 3,\n",
        "    height = 2,\n",
        "    aspect = 1.5,\n",
        "    legend = False,\n",
        "    col_order = ['cty1', 'cty2'] + sorted(df['country_name'].unique())\n",
        ")\n",
        "# loop through each facet\n",
        "for country_name, ax in g.axes_dict.items():\n",
        "    if country_name in ['cty1', 'cty2']:\n",
        "        # Hide axes for dummy facets\n",
        "        ax.axis('off')\n",
        "    else:\n",
        "        # Your normal plotting code\n",
        "        ax.text(.05, .93, country_name, transform = ax.transAxes)\n",
        "        sns.lineplot(\n",
        "            data = df2[df2['country_name'] != country_name],\n",
        "            x = \"date\",\n",
        "            y = \"price_kg\",\n",
        "            units = \"country_name\",\n",
        "            estimator = None,\n",
        "            color = \"black\",\n",
        "            linewidth = 0.2,\n",
        "            ax = ax\n",
        "        )"
      ],
      "id": "9ba326f2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now that I got the base plot, I can add some nice touches. First, I want to set the x-axis to show only years, remove titles and set the y-axis label to XOF.\n"
      ],
      "id": "4f4eef6e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# format x-axis to show only years\n",
        "for ax in g.axes.flatten():\n",
        "    ax.xaxis.set_major_locator(mdates.YearLocator())\n",
        "    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y'))\n",
        "    for label in ax.get_xticklabels():\n",
        "        label.set_rotation(0)\n",
        "        label.set_horizontalalignment('center')\n",
        "    # Enable grid only for major ticks (years)\n",
        "    ax.grid(which='major', axis='x', linestyle='-', linewidth=0.2)\n",
        "\n",
        "# tweak the supporting aspects of the plot\n",
        "g.set_titles(\"\")\n",
        "g.set_axis_labels(\"\", \"XOF\")"
      ],
      "id": "1bdc733c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Second, it's time to set titles, caption, etc."
      ],
      "id": "0b391a95"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# some layout style aka titles and caption\n",
        "palette = sns.color_palette(\"Set2\")\n",
        "title_color = palette[0]\n",
        "title = \"How smooth are changes in local rice prices in Western Sub-Saharan Africa?\"\n",
        "subtitle = \"The graph displays median prices of local rice for 7 sub-saharan countries from 2022 to today, where XOF is the main currency.\"\n",
        "caption = \"Data: HDX - WFP Food Prices | Viz: @gnoblet\"\n",
        "# wrap characters and then add text\n",
        "title_w = \"\\n\".join(textwrap.wrap(title, width = 35))\n",
        "subtitle_w = \"\\n\".join(textwrap.wrap(subtitle, width = 50))\n",
        "plt.figtext(0.05, 0.9, title_w, fontsize = 20, color = title_color, wrap = True)\n",
        "plt.figtext(0.05, 0.75, subtitle_w, fontsize = 16, color = 'black', wrap = True)\n",
        "plt.figtext(0.05, 0.70, caption, fontsize = 12, color = 'black', wrap = True)"
      ],
      "id": "f5078572",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now, we eventually would like to save this plot.\n"
      ],
      "id": "1e1c19a4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# save plot\n",
        "g.figure.savefig('2025/day_19.png', dpi = 300, bbox_inches = 'tight')\n",
        "plt.show()\n",
        "# close plot\n",
        "plt.close()"
      ],
      "id": "433c6f96",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Final Plot\n",
        "\n",
        "![](day_19.png)\n",
        "\n",
        "## Notes\n",
        "\n",
        "This visualization shows the evolution of local rice prices across seven West African countries that use XOF as their currency.\n",
        "\n",
        "Data source: World Food Programme Food Prices dataset (via Humanitarian Data Exchange API)\n",
        "\n",
        "Tools used:\n",
        "- hdx (for accessing the Humanitarian Data Exchange API)\n",
        "- pandas (for data manipulation)\n",
        "- seaborn (for visualization)\n",
        "- matplotlib (for plot customization)\n",
        "\n",
        "The visualization employs small multiples (faceted plots) to compare price trends across countries while maintaining context with faint background lines showing other countries' trends. The analysis addresses data quality issues by standardizing units (converting to price per kg) and calculating median prices by country and date to smooth inconsistencies in the original data."
      ],
      "id": "beaf0775"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}